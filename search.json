[
  {
    "objectID": "posts/exe-optimization.html",
    "href": "posts/exe-optimization.html",
    "title": "Executable Optimization",
    "section": "",
    "text": "When coding in languages such as C or C++, or any other compiled language, I always aim to produce the smallest executable. The reason for that might be an old-school mind created in the floppy disk era where 1.44 mb was enough. Nowadays, it is easier to compile a code that produces executable pretty big even though the software doesn’t do much.\nThe goal of this “tutorial” is to show the steps that I came up with to produce the smallest executable. All the things shown here were done using Windows 11, MSYS2, VS Code and C language, but they can also be applied to many other situations.\nThe testing code uses SDL2 library to show a window that will be open for a few seconds only. Not that matters for this tutorial but, I’ll use it as a basis for other projects. Next is the boiler-plate code that I used:\nWhen compiled, using GCC (Rev3, Built by MSYS2 project) version 14.1.0, the executable generated had the size of 173,495 bytes. For this tutorial, the following line was used to compile the code:"
  },
  {
    "objectID": "posts/exe-optimization.html#gcc",
    "href": "posts/exe-optimization.html#gcc",
    "title": "Executable Optimization",
    "section": "GCC",
    "text": "GCC\nThe first optimization can be done during compiling time. GCC has many optimization flags. Two of those are the most interesting to me, -Os and -flto. According to GCC’s documentation:\n\n-Os: optimizes the executable for size.\n-flto: runs the standard link-time optimizer. Usually, this is used together with the previous one.\n\nAdding the previous flags, the new executable has a size of 158,068 bytes and the compilation command is:\n# the code was simplified for reading purposes\n&gt; gcc ... -Os -flto code.c -o code.exe ..."
  },
  {
    "objectID": "posts/exe-optimization.html#stripping-.reloc",
    "href": "posts/exe-optimization.html#stripping-.reloc",
    "title": "Executable Optimization",
    "section": "Stripping .reloc",
    "text": "Stripping .reloc\nThe next optimization is not related to the compiler used. When executables are generated by a compiler they have the .reloc session which is used for debugging purposes. If you don’t plan to do any debugging with the executable using Ghidra or IDA, you can get rid of this session with the strip.exe included in the binutils of MSYS2. Its usage is as simple as:\n&gt; strip code.exe\nThe .reloc session will be removed from the very same code.exe, therefore no new file is created. The code.exe size is drastically reduced to 23,040 bytes!"
  },
  {
    "objectID": "posts/exe-optimization.html#upx",
    "href": "posts/exe-optimization.html#upx",
    "title": "Executable Optimization",
    "section": "UPX",
    "text": "UPX\nAnother file size optimization is performed by compressing the executable. This new optimization is performed on the executable generated after the previous steps. Tools such as the open-source UPX or the proprietary ASPack can be used for this. There are other similar tools but here I used UPX only. When an executable is compressed with UPX no new file is created. The decompression mechanism is embedded into the same executable and it will decompress during runtime. UPX can also be used to compress other files such as .dlls. To use UPX you do upx executable.exe, however, I also used the flag --best to force the best compression level. So the command line is:\n&gt; upx --best code.exe\nUPX produced a file of only 11,776 bytes, a compression of about 51%."
  },
  {
    "objectID": "posts/exe-optimization.html#summary",
    "href": "posts/exe-optimization.html#summary",
    "title": "Executable Optimization",
    "section": "Summary",
    "text": "Summary\nThe table below summarizes the file size after each step.\n\n\n\nOptimization\nSize (bytes)\n\n\n\n\nNone\n173,495\n\n\n-Os & -flto\n158,068\n\n\nstrip\n23,040\n\n\nUPX\n11,776\n\n\n\nIt is worth remembering that those are incremental optimizations focusing on the file size. Thus, the UPX step has used the output of the strip which has used the result of GCC’s compilation with -Os and -flto. When using UPX there is an extra overhead added because of the decompression mechanism, but I didn’t consider it here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Helder C. R. Oliveira, Ph.D.",
    "section": "",
    "text": "I have Bachelor’s Degree in Computer Science (USP’13, Brazil), M.Sc. (USP’15, Brazil) and Ph.D. (USP’19, Brazil) in Electrical Engineering. From 2019 to 2022 I was a Postdoctoral Fellow at the University of Calgary in Canada.\nMy background is in medical imaging (mammography and digital breast tomosynthesis), machine learning and computer vision. My work with mammography aimed to detect “architectural distortion of the breast”, a very sublet sign of what could become breast cancer. I also worked with denoising filters (BM3D, NLM, Wavelet-based) to remove spared noise when the mammography is acquired with a low radiation dose. During my postdoc, I worked mostly with probabilistic graphical models (Bayesian networks and Structural Equation Modelling) and time-series analysis.\nFor an up-to-date list of publications, please refer to my Google Scholar.\n\nFile6 Project: a hobbyist’s webpage, running in a Beaglebone Black (Single-board Computer - Embedded System) on classic systems, low-level programming, algorithms, malware analysis, and other cool tech projects. It is a working in progress."
  },
  {
    "objectID": "index.html#recent-posts",
    "href": "index.html#recent-posts",
    "title": "Helder C. R. Oliveira, Ph.D.",
    "section": "Recent Posts",
    "text": "Recent Posts"
  },
  {
    "objectID": "oldindex.html",
    "href": "oldindex.html",
    "title": "Helder's Web Page",
    "section": "",
    "text": "Executable Optimization\n\n\n\n\n\n\ncode\n\n\nanalysis\n\n\n\nSome hints on code optimization aiming a small executable\n\n\n\n\n\nSep 28, 2024\n\n\nHelder\n\n\n\n\n\n\nNo matching items"
  }
]